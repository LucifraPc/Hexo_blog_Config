---
title: JavaScript高级
date: 2016-07-22 
categories: 前端
tags:
     - 黑魔法
     - 奇淫技巧
---
## 递归
### 化归思想
由繁化简，由难化易的过程，化归是转化和归结的简称
### 递归的概念
就是函数内部直接或者间接的调用自己
![](http://p1.bpimg.com/567571/592e2d4f9c14a828.jpg)

* 前n项和
* 阶乘
* 求幂  m的n次方
* 斐波那契数列
* 递归获取后代元素（重点记忆）

算法   给定一个

## 作用域
变量的作用范围就是作用域
### 词法作用域
在代码写好的时候，根据代码的书写结构，就能确定变量的作用域，这种作用域就是词法作用域

### 块级作用域（js没有）
代码块中的作用域就是块级作用域

JS中有且只有函数可以创建作用域

### 作用域链
函数可以创建作用域，函数中又可以声明函数，这样就形成了作用域嵌套作用域的链式结构，称之为作用域链

### 变量访问原则
1. 先在当前作用域中进行查找，如果找到了就直接使用
2. 如果没有找到，就去上一级作用域中进行查找，如果找到了就直接使用
3. 如果没有找到，就继续沿着作用域链向上查找，直到找到全局作用域

### 变量提升（hoisting）
JS代码执行分两个阶段：预解析阶段和代码执行阶段

在预解析阶段，会将所有变量的声明和函数声明提升到其所在的作用域的最顶上

* 当函数和变量同名的时候：只提升函数，忽略掉变量声明
* 当函数同名的时候：都会提升，但是后面的会将前面的覆盖掉
* 变量提升是分作用域的
* 变量提升是分段（script）的
* 条件式函数声明：只会提升函数的名称，函数体不会被提升

## 闭包
可以访问独立数据的函数

闭包的实现原理是作用域的访问规则

```js
function outer(){
    var data = "";
    function inner(){
        return data;
    }
    return inner;
}
```

### for循环注册点击事件
### for循环setTimeout

## 缓存cache
将数据临时的存储起来，以提升访问的效率
* 浏览器缓存
* CDN
* 内存
* 数据库缓存

### 使用缓存解决递归实现斐波那契数列的性能问题
### jQuery的缓存实现分析
### jQuery的缓存实现源码解析

## 沙箱
一个隔离的封闭的安全的环境
```js
(function(window){

})(window)
```
## 调用模式
* 函数调用模式
函数名()  this-->window
* 方法调用模式
对象名.方法名(); this--->谁调用就是谁
* 构造函数调用模式
new 函数名(); this--->new 创建出来的对象

* 上下文调用模式
## 上下文调用模式
* call(要将this改成的东西, arg1...argn)
    1.调用函数
    2.把函数内部的this指向第一个参数传入的对象
    3.把第二个及以后的所有参数依次传递给函数作为实参

* apply(要将this改成的东西, 数组或者伪数组)
    1.调用函数
    2.把函数内部的this指向第一个参数传入的对象
    3.会把第二个参数的数组或者伪数组拆解开来，一一传递给函数当做实参

* 伪数组转数组
* 求最大值
