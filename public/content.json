[{"title":"JavaScript从创建对象到继承","date":"2017-07-13T16:00:00.000Z","path":"2017/07/14/JavaScript从创建对象到继承/","text":"创建对象在js的继承之前，先创建一下js对象。JavaScript高级程序设计里面介绍了两种创建自定义单个对象的方法：创建一个 Object() 实例1234567891011121314151617181920var person = new Object()// 创建变量person.name = \"Nick\"person.age = 29person.job = \"FrontEnd Engineer\"// 创建方法person.sayName = function() &#123; console.log(this.name)&#125;对象字面量的方式var person = &#123; // 创建变量 name: \"Nick\", age: 29, job: \"FrontEnd Engineer\", // 创建方法 sayName: function() &#123; console.log(this.name) &#125;&#125; 以上两种方法都创建了单个person对象，这两个person对象都是一样的。我们可以通过“ . ”操作符访问到对象的属性，例如：person.name 的值为 “Nick”。 如果我们现在要创建另一个person对象，假设为person2，我们依然可以按照上面的两种方式创建person2，于是我们又为person2设置name,age…这些属性。那么问题来了，世界上有辣么多人，我们总不能一直按照这种方式创建下去吧。 这个时候我们希望有这么一个函数，当我们输入name，age，job等一些具有标识性的属性之后，它会返回一个我需要的对象给我，于是我们再也不用手动去写那么多重复的代码创建相似对象的代码了，因为这个函数可以复用啊。 这就是以工厂模式成批创建对象： 123456789101112131415// 工厂函数function createPerson(name, age, job) &#123; var obj = new Object() obj.name = name obj.age = age obj.job = job obj.sayName = function() &#123; console.log(this.name) &#125; return obj&#125;var person1 = createPerson(\"张三\", 33, \"搬砖的\")person1.sayName() // \"张三\"var person2 = createPerson(\"李四\", 23, \"杀猪的\")person2.sayName() // \"李四\" 可以看到，工厂模式虽然解决了不用写重复代码的问题，但是却没有解决对象识别问题，即不知道person1和person2是属于什么对象类型（在java中就是它们不知道是属于什么类）。随着JavaScript的发展，又一种新的模式出现了，就是构造函数模式 12345678910111213141516// 按照规定，构造函数的首字母必须大写，以区分和普通函数的差别function Person(name, age, job) &#123; // 创建属性，显式赋给this对象，this指向Person构造函数 this.name = name this.age = age this.job = job // 创建方法 this.sayName = function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person(\"张三\", 33, \"搬砖的\")person1.sayName() // \"张三\"var person2 = new Person(\"李四\", 23, \"杀猪的\")person2.sayName() // \"李四\" 构造函数模式使用new操作符创建对象实例，对象实例还是对象，它的创建过程有四个步骤： 创建一个空对象：var person1 = {} 把Person构造函数的作用域赋给person1： 构造函数的this指向person1 执行构造函数内的代码（this.name = name…）: 为person1对象添加属性或方法 返回新的对象person1（经过2，3步骤加工的） 通过构造函数模式，我们创建的person1，person2有了一个明确的归类，即属于“Person类”。解决了工厂模式的对象识别问题。然而，通过构造函数模式，我们每创建一个person实例，就会执行一次步骤三，即执行赋值属性给this对象，name,age等需要区分的属性确实需要执行，但每个person都有sayName方法，创建一个函数是需要消耗内存的，这里创建了两次，所以要想办法只创建一次，于是我们可以预先创建一个函数，创建实例的时候引用一下就可以了： 12345678910111213// 按照规定，构造函数的首字母必须大写，以区分和普通函数的差别function Person(name, age, job) &#123; // 创建属性，显式赋给this对象，this指向Person构造函数 this.name = name this.age = age this.job = job // 创建方法 this.sayName = sayName&#125;function sayName() &#123; console.log(this.name)&#125; 以上代码在全局作用域创建了一次sayName函数，以后每次引用一下就可以了，就可以不用每次创建了，好像目的已经达到了。可可可可可是，这就没有封装性可言了，而且还会造成全局变量污染。 那有什么办法可以解决这个问题呢？有，在构造函数的原型对象上定义：1234567891011121314151617// 按照规定，构造函数的首字母必须大写，以区分和普通函数的差别function Person(name, age, job) &#123; // 创建属性 this.name = name this.age = age this.job = job &#125;// 在原型对象上定义方法Person.prototype.sayName = function() &#123; console.log(this.name)&#125;var person1 = new Person(\"张三\", 33, \"搬砖的\")person1.sayName() // \"张三\"var person2 = new Person(\"李四\", 23, \"杀猪的\")person2.sayName() // \"李四\" 这里简要介绍一下原型对象。无论什么时候，只要创建了一个函数，这个函数就会拥有一个属性prototype，这个prototype指向函数的原型对象，即12345678function Person(name, age, job) &#123; // 默认属性 this.prototype = 当前函数的原型对象 // 创建属性 this.name = name this.age = age this.job = job &#125; 自定义构造函数的原型对象上（比如本文的Person构造函数）默认只有一个constructor属性，这个constructor属性指向Person()。至于还有一些其他方法都是从Object继承过来的，这里就不扯那么多了。 对于在函数原型对象上定义的属性，这里只讲两点：（更多内容应该去看高级程序设计） 函数原型对象上的属性和方法都是所有实例共享的，值类型可以覆盖，但不能重写：1234567891011121314151617function Person(name, age) &#123; // 创建属性 this.name = name this.age = age &#125; Person.prototype.job = \"搬砖\" var person1 = new Person(\"张三\", 33) console.log(person1.job) // \"搬砖\" // 覆盖 person1.job = \"颠勺\" console.log(person1.job) // \"颠勺\" var person2 = new Person(\"李四\", 43) // 未被重写 console.log(person2.job) // \"搬砖\" 对于在原型对象上定义的引用类型的值，却是可以修改的：1234567891011121314151617function Person(name, age) &#123; // 创建属性 this.name = name this.age = age &#125; Person.prototype.job = [\"搬砖\", \"颠勺\", \"web前端\"] var person1 = new Person(\"张三\", 33) console.log(person1.job) // [\"搬砖\", \"颠勺\", \"web前端\"] // 修改 person1.job.shift() console.log(person1.job) // [\"搬砖\", \"颠勺\"] var person2 = new Person(\"李四\", 43) // 被修改了 console.log(person2.job) // [\"搬砖\", \"颠勺\"] 在Person函数的原型对象上定义sayName方法后，实例person1和person2都可以访问到sayName()，而且访问到的是同一个sayName()，这就解决了sayName()会被创建两次的问题了。JavaScript高级程序设计里还有几种创建对象方式以及对原型对象的详细描述，这里就不提及了，有需要的可以去看看。下面我们正式来聊聊JavaScript的继承。 继承JavaScript的继承是实现继承，即继承实际的方法。是基于原型链的。 JavaScript为什么需要继承？ 回顾一下上文讲的构造函数Person:123456789101112131415// 按照规定，构造函数的首字母必须大写，以区分和普通函数的差别function Person(name, age, job) &#123; // 创建属性 this.name = name this.age = age this.job = job &#125;// 在原型对象上定义方法Person.prototype.sayName = function() &#123; console.log(this.name)&#125;var person1 = new Person(\"张三\", 33, \"搬砖的\")person1.sayName() // \"张三\"person1.age // 33person1.job // \"搬砖的\" 假设现在我需要创建多个相似的man对象，需要通过Man()构造函数创建，这个Man()构造函数拥有Person构造函数的全部属性和方法，同时还要拥有属于自己的属性以及方法。这个时候，我们为了不写重复的代码（按照Person构造函数实现一遍Man），根据许多OO语言的经验，想到了如果可以继承Person定义的属性和方法该多好啊。那么该怎么实现对象的继承呢？用JavaScript特色原型链的方式 1. 组合继承（伪经典继承）实例对象person1拥有Person内部及原型上定义的所有属性和方法，如果让Man()构造函数的原型对象等于person1会发生什么呢？ 对，没错！Man()的原型对象上就会拥有Person原型对象上的所有属性和方法，看代码：12345678910111213141516171819202122232425262728293031// 按照规定，构造函数的首字母必须大写，以区分和普通函数的差别function Person(name, age, job) &#123; // 创建属性 this.name = name this.age = age this.job = job &#125;// 在原型对象上定义方法Person.prototype.sayName = function() &#123; console.log(this.name)&#125;var person1 = new Person()// Man构造函数function Man() &#123; // 定义自己的私有属性 this.name = \"ironman\"&#125;// 还记得每创建一个函数，函数内部都会有一个prototype属性指向当前函数的原型对象吗// 现在将Man的prototype属性更改默认的指向，指向实例对象person1Man.prototype = person1var man1 = new Man()// 实例对象就能访问Man原型对象上的sayName方法了// 注意此时sayName()内部的this指向man1，因为this指向是根据被调用的时候来确定的，此处调用sayName的是实例对象man1man1.sayName() // ironmanconsole.log(person1.age) // undefinedconsole.log(person1.job) // undefined 以上代码中Man()继承了Person()原型上的sayName方法，但并没有继承Person()内部的私有属性（name, age, job）。因为这些属性不能被共享，也就不能定义在原型对象上，那该怎么去继承得到呢。 我们知道，构造函数也是函数，也可以被调用，只不过构造函数还可以用来创建对象罢了。所以我们尝试在Man()内部调用一下Person()看看：1234567891011121314151617181920212223242526272829303132// 按照规定，构造函数的首字母必须大写，以区分和普通函数的差别 function Person(name, age, job) &#123; // 创建属性 this.name = name this.age = age this.job = job &#125; // 在原型对象上定义方法 Person.prototype.sayName = function() &#123; console.log(this.name) &#125; var person1 = new Person() // Man构造函数 function Man(name, age, job) &#123; // 调用Person()，把Person()的this对象换成Man(),并传入三个参数 Person.call(this, name, age, job) // 定义自己的私有属性 this.hobby= \"play ironman\" &#125; // 还记得每创建一个函数，函数内部都会有一个prototype属性指向当前函数的原型对象吗 // 现在将Man的prototype属性更改默认的指向，指向实例对象person1 Man.prototype = person1 var man1 = new Man(\"尼古拉斯\", 23, \"赵四\") man1.sayName() // \"尼古拉斯\" console.log(person1.age) // 23 console.log(person1.job) // 赵四 以上代码我们让Man()接受参数，并把参数传入Person()，我们惊喜的发现Man()内部拥有了name,age,job字段，所以也就继承了Person()内部的属性。这种在子类型构造函数内部调用父类型构造函数的方式叫借用构造函数 继承私有属性和定义在原型对象上的方法已经完成了，这里还有一个问题：还记得Person()原型对象上的constructor属性吗，它是指向Person()的。所以按理来说Man()原型对象上的constructor应该指向Man()! 理论不如实践，试着在Man()内部打印this.constructor，你会发现打印出来了Person()。 咋回事？道理很简单，Man()的原型对象改变了，现在是实例对象person1，所以Man()原型对象的constructor属性指向应该取决于person1的原型对象constructor指向。 由于person1是通过Person()创建的，所以person1的原型对象上的constructor指向Person()。这就很好地验证了前面打印出了Person()了。 既然指向出错了，就要指回来呗：1234567... // 还记得每创建一个函数，函数内部都会有一个prototype属性指向当前函数的原型对象吗// 现在将Man的prototype属性更改默认的指向，指向实例对象person1Man.prototype = person1// 把Man的原型对象上的constructor指回Man()Man.prototype.constructor = Man... 以上完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940// 按照规定，构造函数的首字母必须大写，以区分和普通函数的差别function Person(name, age, job) &#123; // 创建属性 this.name = name this.age = age this.job = job &#125;// 在原型对象上定义方法Person.prototype.sayName = function() &#123; console.log(this.name)&#125;var person1 = new Person()// Man构造函数function Man(name, age, job) &#123; // 调用Person()，把Person()的this对象换成Man(),并传入三个参数 Person.call(this, name, age, job) // 定义自己的私有属性 this.hobby= \"play ironman\"&#125;// 还记得每创建一个函数，函数内部都会有一个prototype属性指向当前函数的原型对象吗// 现在将Man的prototype属性更改默认的指向，指向实例对象person1Man.prototype = person1// 把Man的原型对象上的constructor指回Man()Man.prototype.constructor = Man// 在Man的新原型上定义方法Man.prototype.sayHobby = function() &#123; console.log(this.hobby)&#125;var man1 = new Man(\"王二麻子\", 23, \"打杂的\")man1.sayName() // \"王二麻子\"man1.sayHobby() // \"play ironman\"console.log(person1.age) // 23console.log(person1.job) // 打杂的 通过上面的例子可以得出组合继承的一般形式：12345678910111213141516171819202122232425262728293031323334353637383940// 父对象function Super (name) &#123; this.name = name this.color = ['blue', 'red', 'yello']&#125;Super.prototype.sayName = function () &#123; console.log(this.name)&#125;// 子对象function Sub (name, age) &#123; // 调用父对象的构造函数，继承属性 Super.call(this, name) this.age = age&#125;// 子对象的原型指向父对象的实例，此时子对象的constructor属性指向父对象构造函数// 继承方法Sub.prototype = new Super()// 重新将子对象的constructor指回自身Sub.prototype.constructor = Sub// 在新原型上定义方法Sub.prototype.sayAge = function () &#123; console.log(this.age)&#125;// 创建子对象实例1，修改继承的引用类型属性var instance1 = new Sub('lol', 22)instance1.color.push('pink')console.log(instance1.color) // ['blue', 'red', 'yello','pink']instance1.sayName() // 'lol'instance1.sayAge() // 22// 创建子对象实例2，继承的引用类型属性不会因为实例1的修改而变化var instance2 = new Sub('oop', 33)console.log(instance2.color) // ['blue', 'red', 'yello']instance2.sayName() // 'oop'instance2.sayAge() // 33 2. 原型式继承 （值类型继承）从本质上讲，原型式继承不考虑自定义构造函数，只是对父对象的一次浅复制1234567891011121314151617181920212223242526// 定义一个函数，接受一个需要被继承的父对象，返回一个子对象的实例function object (o) &#123; // 定义一个构造函数F function F() &#123;&#125; // 修改F的原型对象为父对象 F.prototype = o // 返回经过修改原型对象的构造函数F的实例 return new F()&#125;// 定义一个父对象var person = &#123; name: 'seven', friends: ['blob', 'micelid', 'jerry']&#125;// 子对象1var man1 = object(person)man1.friends.shift() // 修改引用类型的值console.log(man1.name) // 'seven'console.log(man1.friends) // ['blob', 'micelid', 'jerry']// 子对象2var man2 = object(person) console.log(man1.name) // 'seven'console.log(man1.friends) // ['blob', 'micelid'] 因为子对象1修改了friends 原型式继承需要注意的是，父对象的引用类型会被不同的实例修改 es5 通过Object.create()函数规范了原型式继承,可以接受第二个参数123456789101112...var man3 = Object.create(person)console.log(man3.name) // 'seven'console.log(man3.friends) // ['blob', 'micelid'] 因为子对象1修改了friendsvar man4 = Object.create(person, &#123; name: &#123; value: 'james' &#125; &#125;)console.log(man4.name) // 'james'console.log(man4.friends) // ['blob', 'micelid'] 因为子对象1修改了friends 3. 寄生式继承 （值类型继承）在主要考虑对象而不是自定义类型或构造函数的情况下使用，在原型式继承的思路上增强了对象（给子对象添加属性）1234567891011function createAnother (original) &#123; // 克隆一个新对象 var clone = Object(original) // 给新对象添加一个方法，增强属性 clone.sayHi = function() &#123; console.log('Hi') &#125; return clone&#125;var another = createAnother(person)another.sayHi() // 'Hi' 4. 寄生组合式继承 （引用类型继承最理想的继承范式）组合继承模式中，每创建一个man实例，都会调用两次Person(),一次是在Man()的内部，一次实在指定子类型原型对象的时候：1234567891011121314...// 子对象function Sub (name, age) &#123; // 调用父对象的构造函数，继承属性 Super.call(this, name) // -----------第二次调用SuperType this.age = age&#125;// 子对象的原型指向父对象的实例，此时子对象的constructor属性指向父对象构造函数// 继承方法Sub.prototype = new Super() // --------------第二次调用SuperType// 重新将子对象的constructor指回自身Sub.prototype.constructor = Sub... 寄生组合式继承借用构造函数继承属性，原型链的混成形式继承方法，解决组合继承需要调用两次构造函数的问题12345678910111213141516171819202122232425262728293031323334353637383940414243// 专门定义一个函数来完成子类型原型对象的更改和原型上constructor属性的指回function inheritPrototype (SubType, SuperType) &#123; // 克隆父对象的原型 var prototype = Object(SuperType.prototype) // 把克隆对象的constructor属性指向子类型 prototype.constructor = SubType // 子类型的原型指向克隆对象 SubType.prototype = prototype&#125;// 父对象function SuperType (name) &#123; this.name = name&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name)&#125;// 子对象function SubType (name, age) &#123; // 继承属性 SuperType.call(this, name) this.age = age&#125; // 原型链混成形式继承父对象原型上的方法inheritPrototype(SubType, SuperType)// 在新原型上定义方法SubType.prototype.sayAge = function () &#123; console.log(this.age)&#125;var sub1 = new SubType('lee', 18)sub1.sayName() // ’lee'sub1.sayAge() // 18var sub2 = new SubType('liu', 28)sub2.sayName() // 'liu'sub2.sayAge() // 28 JavaScript的继承一共有四种方式。可以根据不同的需求使用。仅仅考虑创建相似对象的情况下，继承值类型，建议使用原型式继承；还需要继承引用类型，建议使用寄生式继承继承引用类型的完整继承范式应该是寄生组合式继承，因为相比组合继承寄生组合式继承比较高效（减少调用父类型构造函数的次数）","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"黑魔法","slug":"黑魔法","permalink":"http://yoursite.com/tags/黑魔法/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://yoursite.com/tags/奇淫技巧/"}]},{"title":"我的young","date":"2017-02-15T04:10:25.000Z","path":"2017/02/15/young/","text":"那些花儿 那片笑声让我想起我的那些花儿在我生命每个角落静静为我开着我曾以为我会永远守在他身旁今天我们已经离去在人海茫茫他们都老了吧 他们在哪里呀我们就这样各自奔天涯啦…… 想她啦…… 她还在开吗啦…… 去呀她们已经被风吹走散落在天涯有些故事还没讲完那就算了吧那些心情在岁月中已经难辨真假如今这里荒草丛生没有了鲜花好在曾经拥有你们的春秋和冬夏他们都老了吧 他们在哪里呀我们就这样各自奔天涯啦…… 想她啦…… 她还在开吗啦…… 去呀 她们已经被风吹走散落在天涯Oh~ Where have all the flowers goneWhere the flowers goneWhere have all the young girls goneWhere did they all goneWhere have all the young men goneWhere the soldiers goneWhere have all the graveyards goneWhere have all they gone 他们都老了吧 他们在哪里呀我们就这样各自奔天涯","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}]},{"title":"关于angular的脏检测","date":"2017-02-14T04:10:25.000Z","path":"2017/02/14/angular/","text":"脏检查mvvm双向数据绑定监听js里面值的变化：写一个循环执行的代码取一段时间去取一下值，看看变了没有 $watch使用$watch监听$scope里面值的变化 AngularJS是如何知道什么时候触发$watch？又如何取触发？ 如果你是作者怎么办找一个函数来循环去检查scope中的数据是否发生了变化，发现有变化去更改相应的值 这个函数就是 —-&gt;$scope.$digest() 当更改了$scope里面的值、$timeout、$interval等 自动触发一次$digest循环 $digest $digest循环最少也会运行两次，即使在$watch的回调函数中并没有改变任何model。如果$watch的回调函数中修改了$scope$digest()最多迭代10次 $apply()$digest是一个内部函数，我们没法调用，即使是AngularJS也并不直接调用$digest()，而是调用$scope.$apply()，然后$scope.$apply()调用$rootScope.$digest() 什么时候需要我们手动调用$apply()方法？不在AngularJS的控制范围内去修改$scope里的值例如$interval和setInterval $digest()的遍历 并从$rootScope开始遍历(深度优先)检查数据变更。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"黑魔法","slug":"黑魔法","permalink":"http://yoursite.com/tags/黑魔法/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://yoursite.com/tags/奇淫技巧/"}]},{"title":"Vue的黑魔法","date":"2016-09-22T16:00:00.000Z","path":"2016/09/23/vue2/","text":"vue发送http请求 vue发送http请求，建议使用vue-resource插件。 vue-resource作者尤雨溪、Steffans合作完成 vue-resource优点是特别的小，压缩后才15kb使用vue-resource文档地址https://github.com/pagekit/vue-resource/blob/develop/docs/http.md 1.下载 npm i vue-resource 2.引入页面 编写请求方法 全局中发送http请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124 Vue.http.get('/userList',&#123;params:&#123;\"a\":\"b\"&#125;&#125;) .then(function(res)&#123; console.log(res); &#125;, function(res)&#123; console.log(res); &#125;); //1.路径 2.body 3.options Vue.http.post('/userList',&#123;\"foo\":\"a\"&#125;,&#123;params:&#123;\"a\":\"b\"&#125;&#125;) .then(function(res)&#123; console.log(res); &#125;, function(res)&#123; console.log(res); &#125;);``` - 实例中调用http方法```javascriptvar demo = new Vue(&#123; el: '#app', data: &#123; apiUrl: '/userList' &#125;, create: function() &#123; this.getdata(); &#125;, methods: &#123; getdata: function() &#123; this.$http.get(this.apiUrl,&#123;params:&#123;\"a\":\"b\"&#125;&#125;) .then((response) =&gt; &#123; console.log(response.data); &#125;) .catch(function(response) &#123; console.log(response) &#125;) &#125; &#125; &#125;)``` 4.将页面放入服务器,验证 &lt;div id=\"app\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!-- 如果列表有数据，直接输出表格数据，没有数据提示用户没有数据 --&gt; &lt;tbody v-if=\"UserList.length &gt; 0\"&gt; &lt;tr v-for=\"item in UserList\" &gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.age &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.address &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody v-else&gt; &lt;tr&gt;&lt;td colspan=\"3\"&gt;没有数据奥！&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; var foo = new Vue(&#123; el: '#app', data: &#123; UserList:[] &#125; &#125;); setInterval(function()&#123; foo.UserList.push(&#123;\"name\":\"zyc\",\"age\":88,\"address\":\"七浦路\"&#125;); &#125;,1000) &lt;/script&gt;异步流程控制 promise异步方法想要有执行顺便必须嵌套，回调的地狱.then()```javascript //读文件var fs = require('fs');var rf = function(fileName) &#123; //构建一个 Promise 对象 //resolve成功的方法 //reject失败的方法 return new Promise(function(resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) &#123; reject(error); &#125; else&#123; resolve(data.toString()); &#125; &#125;); &#125;); &#125;; rf('1.txt').then(function(data) &#123; console.log(data); return new Promise(function(resolve, reject) &#123; fs.readFile('1.txt', function(error, data) &#123; if (error) &#123; console.log(1231231232); reject(error); &#125; else&#123; resolve(data.toString()); &#125; &#125;); &#125;); &#125;).then(function(data) &#123; console.log(data); return new Promise(function(resolve, reject) &#123; fs.readFile('1.txt', function(error, data) &#123; if (error) &#123; reject(error); &#125; else&#123; resolve(data.toString()); &#125; &#125;); &#125;); &#125;); vue组件组件系统是Vue.js其中一个重要的概念，它提供了一种抽象，让我们可以使用独立可复用的小组件来构建大型应用，任意类型的应用界面都可以抽象为一个组件树： 定义全局的组件&lt;div id=&quot;app&quot;&gt; &lt;!-- 3. #app是Vue实例挂载的元素，应该在挂载元素范围内使用组件--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; // 1.创建一个组件构造器，定义一个组件 var myComponent = Vue.extend({ //template用来定义html部分 template: &apos;&lt;div&gt;囧囧&lt;/div&gt;&apos; }) // 2.注册组件 第一个参数是组件的名称，第二个是构造后的组件 //全局注册，在当前页面中所有的被Vue控制的页面元素随意使用 Vue.component(&apos;my-component&apos;, myComponent) new Vue({ el: &apos;#app&apos; }); &lt;/script&gt; 总结 Vue.extend()是Vue构造器的扩展，调用Vue.extend()创建的是一个组件构造器。 Vue.extend()构造器有一个选项对象，选项对象的template属性用于定义组件要渲染的HTML。 使用Vue.component()注册组件时，需要提供2个参数，第1个参数时组件的标签，第2个参数是组件构造器。 组件应该挂载到某个Vue实例下，否则它不会生效。 注意点： 可以使用 单独写，在非vue控制区不可以使用 可以替代自定义指令 定义局部组件 只把组件注册给了demo1这个实例var myComponent = Vue.extend({ template: &apos;&lt;div&gt;囧囧!&lt;/div&gt;&apos; }) var demo1=new Vue({ el: &apos;#app&apos;, components: { // 将myComponent组件注册到Vue实例下 &apos;my-component&apos;: myComponent } }); 注意点:如果在建一个实例没有注册my-component则不能使用 组件的互相调用 &lt;div id=&quot;app&quot;&gt; &lt;parent-component&gt; &lt;/parent-component&gt; &lt;/div&gt; &lt;script&gt; var Child = Vue.extend({ template: &apos;&lt;p&gt;儿子&lt;/p&gt;&apos; }) var Parent = Vue.extend({ //child-component调用儿子组件 template :&apos;&lt;p&gt;父亲&lt;/p&gt;&lt;child-component&gt;&lt;/child-component&gt;&apos;, components: { //注册儿子 &apos;child-component&apos;: Child } }) // 全局注册Parent组件 Vue.component(&apos;parent-component&apos;, Parent) new Vue({ el: &apos;#app&apos; }) &lt;/script&gt; 注意点:template不支持添加多个dom节点，只能有一个根元素 语法糖： var child={ template:”儿子“ } 替代 var Child = Vue.extend({ template: ‘儿子‘ }) 组件的嵌套写法 组件的互相调用 &lt;div id=&quot;app&quot;&gt; &lt;parent-component&gt; &lt;/parent-component&gt; &lt;/div&gt; &lt;script&gt; var Parent = Vue.extend({ //child-component调用儿子组件 template :&apos;&lt;div&gt;&lt;p&gt;父亲&lt;/p&gt;&lt;child-component&gt;&lt;/child-component&gt;&lt;/div&gt;&apos;, components: { //注册儿子 &apos;child-component&apos;: Vue.extend({ template: &apos;&lt;p&gt;儿子&lt;/p&gt;&apos; }) } }) // 全局注册Parent组件 Vue.component(&apos;parent-component&apos;, Parent) new Vue({ el: &apos;#app&apos; }) 组件之间传值使用prop传递数据组件实例的作用域是孤立的，这意味着不能并且也不应该在子组件的模板内直接引用父组件的数据。可以使用props把数据传递过去。 &lt;div id=&quot;app&quot;&gt; &lt;parent-component&gt; &lt;/parent-component&gt; &lt;/div&gt; &lt;script&gt; var Child = Vue.extend({ props:[&apos;myMsg&apos;], template: &apos;&lt;p&gt;{{myMsg}}&lt;/p&gt;&apos; }) var Parent = Vue.extend({ //child-component调用儿子组件 //在标签里面不支持驼峰，修改成-连接两单词 template :&apos;&lt;p&gt;父亲&lt;/p&gt;&lt;child-component my-msg=&quot;foo&quot; &gt;&lt;/child-component&gt;&apos;, components: { //注册儿子 &apos;child-component&apos;: Child } }) // 全局注册Parent组件 Vue.component(&apos;parent-component&apos;, Parent) new Vue({ el: &apos;#app&apos; }) 动态prop &lt;div id=&quot;app&quot;&gt; &lt;parent-component&gt; &lt;/parent-component&gt; &lt;/div&gt; &lt;script&gt; var Child = Vue.extend({ props:[&apos;myMsg&apos;], template: &apos;&lt;p&gt;{{myMsg}}&lt;/p&gt;&apos; }) var Parent = Vue.extend({ //child-component调用儿子组件 //在标签里面不支持驼峰，修改成-连接两单词 template :&apos;&lt;input v-model=&quot;parentMsg&quot;&gt;&lt;child-component :my-msg=&quot;parentMsg&quot; &gt;&lt;/child-component&gt;&apos;, components: { //注册儿子 &apos;child-component&apos;: Child }, data:function(){ return {&quot;parentMsg&quot;:&quot;&quot;} } }) // 全局注册Parent组件 Vue.component(&apos;parent-component&apos;, Parent) new Vue({ el: &apos;#app&apos; data:{ } }) webpackwebpack网站官网http://webpack.github.io/1.X官方文档http://webpack.github.io/docs/ 什么是webpack？webpack is a module bundler.webpack是一个模块化的打包工具。—-&gt;先抛开node.jssea.js+符合CMD规范开发的js文件———-&gt;一起引入html进行执行符合CMD规范开发的js文件—通过webpack的解析—-&gt;合并成一个js文件—&gt;引入html进行执行 webpack所支持的规范CMD、AMD、CommonJS、ES2015 module webpack的使用安装命令npm i webpack -g使用命令webpack ./app.js app.bundle.js webpack配置文件 文件名—&gt;webpack.config.js 配置文件,使用module.exports曝露出对象 通过对对象属性的设置进而设置webpack的任务1234567module.exports = &#123; entry: './src/app.js', output: &#123; path: './bin', filename: 'app.bundle.js', &#125;&#125; entry属性：用来配置要打包的入口文件值可以是 字符串 entry: ‘./src/app.js’ 数组 entry: [‘./src/app1.js’,’./src/app2.js’] 对象 对象的键名这里称之为块名（代码块的意思），块名可以在output属性中使用 12345678entry: &#123; app1:\"./src/app1.js\", app2:\"./src/app2.js\",&#125; output: &#123; path: './bin', filename: '[name].bundle.js',&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"黑魔法","slug":"黑魔法","permalink":"http://yoursite.com/tags/黑魔法/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://yoursite.com/tags/奇淫技巧/"}]},{"title":"CSS自适应布局总结","date":"2016-07-21T16:00:00.000Z","path":"2016/07/22/css/","text":"这可能是史上最全的CSS自适应布局总结 标题严格遵守了新广告法，你再不爽，我也没犯法呀！屁话不多说，直入！ 所谓布局，其实包含两个含义：尺寸与定位。也就是说，所有与尺寸和定位相关的属性，都可以用来布局。 大体上，布局中会用到的有：尺寸相关的盒子模型，普通流、浮动、绝对定位三种定位机制，CSS3中的transform、弹性盒子模块、试验中的grid模块。逛园子的时候经常可以看到浮动布局，inline-block布局，弹性盒布局这几个名词。现在对布局也算有一点了解，做个总结巩固一下。如果你也看了很多资料，但是实际动手时对布局还是无从下手的话，希望本文可以帮你理清思路。 唠叨一句：看到一个效果图的时候，千万不要急着手贱去敲代码！先思考清楚页面的构造，理清各元素之间的关系，特别需要注意的是在不同的设备下需要有怎样的展现，当你思路清晰找到最好的布局方案时，coding其实真的不需要多少时间。 尺寸相关为什么要先说尺寸呢？因为尺寸在布局中的作用非常核心，布局方式定位这些只是改变了元素之间的关系，没有尺寸就什么也不是。比如我们通常会用margin来控制跟其他元素的距离，这就是布局。 很多人都会觉得，什么width、margin太简单了，早就掌握了。这种心态我一开始学习CSS的时候也有，觉得很好理解很简单，但是后面才发现自己原来很多东西都没真正掌握。看看张鑫旭大神给我们上的政治课：http://www.zhangxinxu.com/wordpress/2012/07/bottleneck-css-study/ 先说说百分比，百分比是相对父对象的，这里特性非常好用，很多时候会用在自适应布局上面。浏览器尺寸的改变，就是根节点html的长宽改变，我们可以用%来将浏览器尺寸和元素尺寸联系起来，做到自适应。 另外一个比较有意思的是auto，auto是很多尺寸值的默认值，也就是由浏览器自动计算。首先是块级元素水平方向的auto，块级元素的margin、border、padding以及content宽度之和等于父元素width。使用auto属性在父元素宽度变化的时候，该元素的宽度也会随之变化。 但是当该元素被设为浮动时，该元素的width就变成了内容的宽度了，由内容撑开，也就是所谓的有了包裹性。overflow | position:absolute | float:left/right都可以产生包裹性，替换元素也同样具有包裹性。在具有包裹性的元素上想利用width : auto；来让元素宽度自适应浏览器宽是不行的。 高度方向：外边距重叠，外边距auto为0，这两点需要注意。书写方向什么的，接触比较少就不扯了。 那为什么margin：auto对不能计算垂直方向的值呢？很简单，垂直方向是被设计成可以无限扩展的，内容越多浏览器便产生滚动条来扩展，所以垂直方向都找不到一个计算基准，以此返回一个false，便成了0。 用处：通过width、height控制大小，各个方向的margin值控制与边界或者其他元素的距离来定位。 浮动目前PC网站大多使用float布局，从成本上考虑大改的概率很小，所以不要说浮动无用，总是会有机会让你维护的！代表网站：淘宝、腾讯、百度，好吧BAT都到齐了。 浮动听得多了，博客园上关于用浮动布局的介绍也非常的多。浮动原本用于文本环绕，但却在布局被发扬光大，这就是命！我的理解：浮动布局的核心就是让元素脱离普通流，然后使用width/height，margin/padding将元素定位。脱离普通流的元素，就像脱离地心引力一样，与普通流不在一个高度上。这个跟图层的概念类似。高度不同所以可以叠在其他元素上面产生重叠或者使用负边距跑到父元素外，理解了这一点浮动布局就很好理解了。 下面用个圣杯布局的例子说明一下，理解了这个之后其他布局更加简单： left，宽度固定,高度可固定也可由内容撑开 right，宽度固定，高度可固定也可由内容撑开 center，可以自适应浏览器宽度，高度可固定也可由内容撑开。 原理非常简单，左右侧边栏定宽并浮动，中部内容区放最后不浮动、默认width：auto并设置相应外边距，让左右侧边栏浮动到上面。注意：子元素设置为浮动之后，父对象的高度就坍塌了，需要设置父对象后的元素清除浮动，这样父对象的高度才能被浮动子元素撑起来了。 当然，我们也要问一下，为啥父对象高度会坍塌呢？上面也说过了，浮动元素已经脱离了普通流，父对象所在的普通流比喻成地表，那浮动元素就已经上天了。但是父对象还在地表啊，从外太空看浮动元素在父对象里面，但是其实并不在，又怎么能撑开父对象呢？宽度如果我们不设置的话，其实也是为0的，因为父对象里面空空如也，所以宽高为0。 要撑开的办法就两个 是让父对象也上天（。。。你咋不上天呢），2是把浮动元素的边框边界拉下来。 父对象也上天（即浮动）的话，那就不能实现宽度自适应了。因为float元素的width：auto是包裹内容的，参考前面说的！ 就是在后面的元素里加一个clear语句。说到这个问题就要扯到clear与BFC了，我就不献丑了。传送门：https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear 这个三列布局还有个双飞（是双飞翼！想啥呢）的变种，就是在HTML中center部分也就是内容区提到最前面，也就是内容先行渲染。在网络不好的时候，左右双翼能不能出来不要紧，先让主体内容出来！这种想法，明显的优秀工程师思维，但，尼玛的双翼都是广告啊。广告不出来，哪能赚钱养你们这群工程师？所以提出双飞的玉伯才离开了淘宝？？？（纯属意淫，如真属实，当我扯淡，哈哈哈！） 思路： 既然HTML里面要让center放前面，为了让left跑到center前面，那center也必须浮动了，否则因为都是块元素他们会分两行。 浮动之后还要让center宽度自适应，那明显width只能100%，然后在父元素中设width:auto，还有两侧margin，其实也就是父对象宽度自适应，center只是继承content的宽度。 对left使用负的margin让他们浮动到上方去。 代码里面我用到了一个calc()，这个CSS3带来的计算函数简直酷毙了！本例里如果不使用calc函数，那么就需要wrap左边距为0，left左边距-100%，然后center多加一层子块DIV设置margin-left：100px，可以达到同样的效果！calc函数与百分比配合就足以实现自适应的要求！目前所有的自适应布局都在利用浏览器来为我们计算尺寸，但是有了calc之后我们就可以自己制定规则！单是想想都高潮了吧？ 总结：使用浮动来进行布局，一个比较大的问题是清除浮动。这个可以使用一个after伪类来清除。更大的问题是浮动性像水一样向上流动，难以把握。在元素较多而且元素高度尺寸不一的情况下，单纯使用浮动只能实现上端对齐，这对于适应多种设备的布局就显得力不从心了。目前的做法是牺牲一部分内容，将元素做成等高排列，从美观上看也当然也是极好的，比参差不齐的排列要美观。 普通流布局普通流布局：display : inline-block！这是一个传说中取代float布局的存在。看了一些网站，PC端浮动为主，移动端的也用的不多啊，已经有些使用flex的了，说好的inline-block一统江湖呢？ 使用inline-block之前先处理点小障碍：inline-block元素会有4px左右的空隙，这个是因为我们写代码时候的换行符所致。 解决办法很简单：在inline-block的父元素中设置样式font-size：0；letter-spacing: -4px; 然后设置inline-block的所有兄弟元素 font-size：值；letter-spacing: 值px; 恢复正常的显示。 另外还有一点需要注意的是inline-block默认是基线对齐的，而inline-block的基线又跟文本基线一致，所以在内容不同的时候并不能水平对齐。只需要用vertical-align显式声明一下top/bottom/middle对齐即可。这里补充一下基线的内容，没你想的那么简单哦。分有文字和无文字两种情况： 无文字：容器的margin-bottom下边缘。与容器内部的元素没一毛钱关系。 有文字：最后一行文字的下边缘，跟文字块（p,h等）的margin、padding没关系！注意是最后一行，无论文字在什么子对象容器内在什么位置都没关系，浏览器会找到最后一行文字对齐底部。 你们感受一下： 警示：inline-block的基线是最后一行文字的底部，flex里面的基线是第一行文字的底部（请看下文阮老师的文章） 满满的都是泪啊。。。既然都叫baseline，何必呢？ 使用inline-block进行圣杯布局：这里也没什么好说的，用到的也是width：auto和width：100%这两点，简单知识点的简单用法。 双飞的话，代码跟圣杯的基本相同，注意在html的顺序变为center&gt;right&gt;left，只改左栏移动的margin-left: calc(-100% – 100px)到预定位置即可。不能用calc的话可以在center里面再加一层，跟浮动一样的处理方式。更简单的方法是使用CSS3带给我们的box-sizing属性。请看代码： 总结：相比浮动inline-block更加容易理解，也更符合我们的认知，结合盒子模型的几个控制属性就可以进行布局了。对于元素高度不同的情况，目前浮动布局的做法都是将元素做成等高元素进行展现，这从美学上看也符合整齐的要求，不过牺牲了一部分内容。但inline-block有vertical-align属性，可以很好地解决元素高度不同而带来的布局问题。用过之后，你也会喜欢上inline-block的。。。至少我会！ 绝对定位前面的浮动和普通流中其实定位都是靠盒子模型控制的，与我们常说的定位还是有差别的。而绝对定位就是我们平常所说的定位，给定参考坐标系+坐标确定位置。关于绝对定位的资料太多，我就不说了。提一点就是absolute定位的基准是最近的非static定位父对象，而fixed是相对html根节点的定位。两种定位都会脱离普通流，跟之前说的浮动一样，上天了。 当然，他们跟浮动在空间中的位置还是有差别的，项目中有遇到这个问题的请参考张大婶的文章： http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/ 还是要结合项目来看，否则看过也只是看过而已，并不会存到你的脑子里，毕竟还是相当抽象相当理论性的东西。借用张大神的一个总结图： 使用绝对定位（特指absolute）做自适应布局跟前面两种方式没太大差别，宽度自适应还是在auto和100%上做文章，而位置则由top/bottom/left/right等控制。还是以圣杯布局来举例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;宽度自适应布局&lt;/title&gt; &lt;style&gt; .wrap &#123; position: relative; background-color: yellow; margin-left: 100px; margin-right: 150px; height: 250px; &#125; .left &#123; position: absolute; top: 0; left: -100px; width: 100px; background: skyblue; height: 180px; &#125; .right &#123; position: absolute; top: 0; right: 0; width: 150px; background: hotpink; height: 200px; margin-right: -150px; &#125; .center &#123; position: absolute; top: 0; left: 0; background: #B373DA; height: 150px; min-width: 150px; width: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt; center，可以自适应浏览器宽度，高度固定。 &lt;/div&gt; &lt;div class=\"left\"&gt;left，宽度高度固定&lt;/div&gt; &lt;div class=\"right\"&gt;right，宽度高度固定&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 父元素为relative，子元素为absolute，这样的话，又会出现跟浮动一样的问题：父对象高度坍塌，子元素不能撑起父对象。原因也跟浮动一样，解决办法的话目前我知道的只有给父对象指定一个确定height值，大家如果有更好的办法，请联系我！ 总结：单纯使用绝对定位进行自适应布局的情况很少，一般绝对定位都用在尺寸固定的元素定位上。而且fixed定位的渲染效率很低，因为它会频繁触发浏览器的重排。另外提一点：CSS3的transform会对绝对定位产生影响哦~比如说让fixed定位不再固定在浏览器视窗的黑魔法：[http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/] 弹性盒子CSS3中对布局影响最大的莫过于弹性盒子模块了，这是一套区别于以往盒子模型布局的全新方案。上面几种方法你可以看到，为了实现自适应我们用的都是width：auto和100%的嵌套以及各种边距的移动定位，这套规则并不符合我们的认知。为什么不能开拓出一块区域，横竖排列都可以，内部所有元素的尺寸可以按照一个规则和这个区域的大小联系起来？终于CSS3做出了改变，引入了flex弹性布局方案，弹性盒布局有如下优势： 独立的高度控制与对齐。 独立的元素顺序。 指定元素之间的关系。 灵活的尺寸与对齐方式。 在MDN上有非常简单易懂的基础教程：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes 上面也已经给出了圣杯布局的自适应布局方案，所以代码就不贴了不过这个例子实现的是3栏成比例缩放，左右栏如果需要固定值的话可以写成 flex: 0 0 150px; 的样式。 但是上面的教程没有给出各个属性的详细解释，建议看看阮一峰的博文，详细易懂而且配图超漂亮的有木有：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 总结：弹性盒子在移动端的应用会越来越普遍，这套模型值得去好好研究。语法规则都是非常贴近人性，非常灵活，浏览器兼容性也非常好，当然国内百花齐放的移动浏览器会有哪些大坑呢？我们拭目以待~ 其他其他包括position：relative和CSS3中的transform都可以实现定位，但是由于他们在原来的普通流中还占着一个坑，所以很少用来布局啥的。transform是个很酷炫的东西，可以用平面的素材做出很多3D的效果，而且不需要js就可以做，非常好玩。此文已经很长，就不多说了，以后会写一篇文章来专门说说她的故事。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"黑魔法","slug":"黑魔法","permalink":"http://yoursite.com/tags/黑魔法/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://yoursite.com/tags/奇淫技巧/"}]},{"title":"JavaScript高级","date":"2016-07-21T16:00:00.000Z","path":"2016/07/22/js/","text":"递归化归思想由繁化简，由难化易的过程，化归是转化和归结的简称 递归的概念就是函数内部直接或者间接的调用自己 前n项和 阶乘 求幂 m的n次方 斐波那契数列 递归获取后代元素（重点记忆） 算法 给定一个 作用域变量的作用范围就是作用域 词法作用域在代码写好的时候，根据代码的书写结构，就能确定变量的作用域，这种作用域就是词法作用域 块级作用域（js没有）代码块中的作用域就是块级作用域 JS中有且只有函数可以创建作用域 作用域链函数可以创建作用域，函数中又可以声明函数，这样就形成了作用域嵌套作用域的链式结构，称之为作用域链 变量访问原则 先在当前作用域中进行查找，如果找到了就直接使用 如果没有找到，就去上一级作用域中进行查找，如果找到了就直接使用 如果没有找到，就继续沿着作用域链向上查找，直到找到全局作用域 变量提升（hoisting）JS代码执行分两个阶段：预解析阶段和代码执行阶段 在预解析阶段，会将所有变量的声明和函数声明提升到其所在的作用域的最顶上 当函数和变量同名的时候：只提升函数，忽略掉变量声明 当函数同名的时候：都会提升，但是后面的会将前面的覆盖掉 变量提升是分作用域的 变量提升是分段（script）的 条件式函数声明：只会提升函数的名称，函数体不会被提升 闭包可以访问独立数据的函数 闭包的实现原理是作用域的访问规则 1234567function outer()&#123; var data = \"\"; function inner()&#123; return data; &#125; return inner;&#125; for循环注册点击事件for循环setTimeout缓存cache将数据临时的存储起来，以提升访问的效率 浏览器缓存 CDN 内存 数据库缓存 使用缓存解决递归实现斐波那契数列的性能问题jQuery的缓存实现分析jQuery的缓存实现源码解析沙箱一个隔离的封闭的安全的环境123(function(window)&#123;&#125;)(window) 调用模式 函数调用模式函数名() this–&gt;window 方法调用模式对象名.方法名(); this—&gt;谁调用就是谁 构造函数调用模式new 函数名(); this—&gt;new 创建出来的对象 上下文调用模式 上下文调用模式 call(要将this改成的东西, arg1…argn) 1.调用函数 2.把函数内部的this指向第一个参数传入的对象 3.把第二个及以后的所有参数依次传递给函数作为实参 apply(要将this改成的东西, 数组或者伪数组) 1.调用函数 2.把函数内部的this指向第一个参数传入的对象 3.会把第二个参数的数组或者伪数组拆解开来，一一传递给函数当做实参 伪数组转数组 求最大值","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"黑魔法","slug":"黑魔法","permalink":"http://yoursite.com/tags/黑魔法/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://yoursite.com/tags/奇淫技巧/"}]}]